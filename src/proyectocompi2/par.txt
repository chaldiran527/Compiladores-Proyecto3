/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
package proyectocompi2;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.io.IOException;
import java.io.FileWriter;
import java.util.List;
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.io.*;
import java.util.*;

//Acciones predefinidas por el codigo proporcionado en la pagina de CUP
action code {:

    //Funcion que sirve para imprimir la tabla de simbolos
    //No tiene params de entrada ni de salida
//    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<String, ArrayList<String>>();
    LinkedHashMap<String, ArrayList<String>> listaTablasSimbolos = new LinkedHashMap<String, ArrayList<String>>();
    ArrayList<FunctionObject> funcs = new ArrayList<FunctionObject>();
    HashMap<String, TablaSimbolo> pilaSimbolos = new HashMap<String, TablaSimbolo>();
    String currHash = "";
    String globalHash = "globalTS";

    /*Funcion para imprimir en consola la tabla de simbolos generada en el parse
    */
    public void imprimirTablaSimbolos(){
        for(String key: listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de simbolo: " + key);
            System.out.println("Valores : ");
            for(String item : listaTablasSimbolos.get(key)){
                System.out.print(item);
            }
            System.out.println("");
        }
    }

public void escribirTablaSimbolos() {
    String filePath = "C:\\Users\\Usuario\\Documents\\NetBeansProjects\\ProyectoCompi2\\src\\proyectocompi2\\outputParser.txt";;
    try (BufferedWriter writer = new BufferedWriter(new FileWriter(filePath))) {
        for (String key : listaTablasSimbolos.keySet()) {
            writer.write("\nTabla de simbolo: " + key + "\n");
            writer.write("Valores : \n");
            for (String item : listaTablasSimbolos.get(key)) {
                writer.write(item);
            }
            writer.write("\n");
        }
    } catch (IOException e) {
        System.err.println("Error escribiendo al archivo: " + e.getMessage());
    }
}


    /*Funcion que recibe la tabla de simbolos y el id como hilera para retornar el tipo
    */
/*
    public String getTipo(ArrayList<String> tablasSimbolos, String id){
        String tipo = "null";
        for (String token : tablasSimbolos){
            String[] partesToken = token.split(":");
            if(id.equals(partesToken[0])){
                tipo = partesToken[1];
            }
        }
    }
*/
    public TipoDato validarTipos(String ope, Dato op1, Dato op2, ArrayList<TipoDato> tipos) {
      if (op1.getTipo() != op2.getTipo()) {//Se valida la igualdad de tipos
        //System.out.println("Error sem√°ntico en la linea " + (lex.getLine()+1) + " Columna " + (lex.getColumn()+1) + ": " + "Expresiones " + op1.getTipo().toString() + ", " + op2.getTipo().toString() + " incompatibles para realizar la " + ope);
        semantic_error("misc",("Error semantico en la linea " + (lex.getLine()+1) + " Columna " + (lex.getColumn()+1) + ": " + "Expresiones " + op1.getTipo().toString() + ", " + op2.getTipo().toString() + " incompatibles para realizar la " + ope));
        return TipoDato.NULO;
      }
      if (!tipos.contains(op1.getTipo())) {
        //System.out.println("Error semantico en linea: " + (lex.getLine()+1) + " Columna:" + (lex.getColumn()+1) + ": " + "Tipo " + op1.getTipo().toString() + " invalido para" + ope);
        semantic_error("misc",("Error semantico en la linea " + (lex.getLine()+1) + " Columna " + (lex.getColumn()+1) + ": " + "Expresiones " + op1.getTipo().toString() + ", " + op2.getTipo().toString() + " incompatibles para realizar la " + ope));
        return TipoDato.NULO;
      }
      return op1.getTipo();
    }

    public String existeValor(String pSim){
      for (Simbolo valor : pilaSimbolos.get(currHash).getTablaSimbolos()) {
        if (valor.getId() == pSim) {
          //return value.getDireccion();
          return " ";
        }
      }
      return null;
    }

    public FunctionObject buscarFunc(String pId){
      for(FunctionObject func : funcs){
        if(func.getIdFuncion().equals(pId)){
            return func;
        }
      }
      return null;
    }


    public TipoDato getTipo(String pId, boolean reportar){
        for (Simbolo dato : pilaSimbolos.get(currHash).getTablaSimbolos()) {
              System.out.println("A: "+dato.getId());
          if (dato.getId().equals(pId)) {
            return Dato.tipoFromString(dato.getTipo());
          }
        }
        if (reportar){
          semantic_error("misc", ("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que no se ha definido el id: " + pId));
        }
        return TipoDato.NULO;
    }


    public void hola(){
        System.out.println("Hola");
    }

    public void adios(){
        System.out.println("Adios");
    }
:}

parser code {:
    // Connect this parser to a scanner!
    Lexer lex;
    boolean syntaxError;
    ArrayList<String> errores = new ArrayList<String>();
    String errorActual = "";
    @SuppressWarnings("deprecation")
    public parser(Lexer lex){
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.syntaxError = false; // Inicializar el booleano de errores
    }


    /*Funcion syntax_error sobreescrita para el manejo de errores en idioma espaniol 
    Recibe de parametro el symbol del token actual en el que se ha encontrado un error
    No retorna nada 
    */
    public void syntax_error(Symbol errorSymbol) {//Se imprime la linea y columna del error
        errorActual = "Error sintactico en la linea: " + errorSymbol.left + ", y columna " + errorSymbol.right;
        //System.err.println("Error sintactico en la linea: " + errorSymbol.left + ", y columna " + errorSymbol.right );
        this.errores.add(errorActual);
        this.syntaxError = true; //El booleano se pone en true para indicar que se encontro un error 
    }

    public void semantic_error(String pTipo, String pExpresion){
        switch(pTipo){
          case "local":
              //System.out.println("Error semantico local en la linea " + (lex.getLine()+1) + " columna " + lex.getColumn() + ": " + "Debido al dato ya existente: " + pExpresion);
              errorActual = "Error semantico en la linea " + (lex.getLine()+1) + " columna " + lex.getColumn() + ": " + "Debido a la variable ya existente: " + pExpresion;
              this.errores.add(errorActual);
              this.syntaxError = true;
              break;
          case "param":
              //System.out.println("Error semantico local en la linea " + (lex.getLine()+1) + " columna " + lex.getColumn() + ": " + "Debido al dato ya existente: " + pExpresion);
              errorActual = "Error semantico en la linea " + (lex.getLine()+1) + " columna " + lex.getColumn() + ": " + "Debido al parametro repetido: " + pExpresion;
              this.errores.add(errorActual);
              this.syntaxError = true;
              break;
          case "fun":
              //System.out.println("Error semantico local en la linea " + (lex.getLine()+1) + " columna " + lex.getColumn() + ": " + "Debido al dato ya existente: " + pExpresion);
              errorActual = "Error semantico en la linea " + (lex.getLine()+1) + " columna " + lex.getColumn() + ": " + "Debido a la funcion ya existente: " + pExpresion;
              this.errores.add(errorActual);
              this.syntaxError = true;
              break;
          case "main":
              errorActual = "Error semantico debido a que no existe funcion main";
              this.errores.add(errorActual);
              this.syntaxError = true;
              break;
          case "ftipo":
              errorActual = "Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "El tipo " + pExpresion + " no es valido para una funcion";
              this.errores.add(errorActual);
              this.syntaxError = true;
              break;
           case "misc":
              this.errores.add(pExpresion);
              this.syntaxError = true;
              break;

//variable no existente: var
//mal retorno: return
//mala asignacion: assign
//
          
        }
    }
    // Metodo que verifica si hubo un error sintactico, el cual no recibe ni retorna valores 
    public boolean huboError() {
        return syntaxError;
    }

    //Metodo que imprime si hubo error sintactico y si la gramatica puede ser generada 
    public void estadoGramatica() {
        if (huboError()) {
            System.out.println("El archivo fuente no puede ser generado por la gramatica, debido a errores encontrados en estas partes del archivo:\n");
            for(String currentError : errores){
                System.out.println("\t " + currentError);            
            }

        } else {
            System.out.println("El archivo fuente si puede ser generado por la gramatica");
        }
    }
:}

/* Se define la manera en que se conecta al scanner */
init with {: :};
scan with {: return lex.next_token(); :};

//Terminales de parentesis y llaves
terminal ABREREGALO, CIERRAREGALO, ABREEMPAQUE, CIERRAEMPAQUE, ABRECUENTO, CIERRACUENTO, SEPARAREGALO;

//Terminales de tipos
terminal t_float_santa, t_bool_colacho, t_string_nicolas, l_MINIREGALO, l_int_dedmoroz, t_arr_noel, t_int_sinterklass, l_float_padrenavidad;//

//Terminal de positivos enteros no cero


//Terminales relacionales
terminal e_jinglebell, ne_tinseltoes, g_merryberry, l_slinky, ge_snowflake, le_candycane;

//Terminal de finalizador
terminal FINREGALO;

//Terminales aritmeticos unarios de  decremento e incremento
terminal QUIEN, GRINCH;

//Terminales aritmeticos binarios
terminal sum_dasher, res_dancer, mul_prancer, div_int_vixen, div_float_blitzen, mod_comet, pow_cupid;

//Terminales operadores logicos
terminal not_gaspar, and_melchior, or_balthassar, l_fPAPANOEL, l_tPAPANOEL;

//Terminales estructuras de control (if, elif, else, for, do, until, return, break, while, switch)
terminal ELFO, HADA, DUENDE, ENVUELVE, HACE, REVISA, ENVIA, CORTA, ESPERARASANTA, TRINEO;

//Terminales de identificador, entrega, return y ERROR
terminal PERSONA, NAVIDAD, INTEGER_LITERAL, ENTREGA, RETORNAREGALO, SINREGALO, FESTIVAL, LUCES, ARBOL, t_char_dedmoroz, l_string_nicolas, NATIVIDAD, ERROR;


//Terminales de lectura y escritura
terminal NARRA, ESCUCHA;

//No terminales palabras reservadas y tipos de datos 
non terminal tsantaclaus, tlsantaclaus; 

//No terminales de funciones
non terminal bolsaNavidena, bolsaNavidenaAux, defBolsaNavidena, bolsasNavidenas, codigoBolsaNavidena;

//No terminales de multiples parametros
non terminal paramBastoncitos, defParamBastoncito, expresionesBastoncitos, defExprBastoncito;

//No terminales de lineas y sentencias de codigo 
non terminal lineasDeNavidad, auxLineasDeNavidad, creaRegalo, asignaRegalo, asignaMultiplesRegalos; 

//No terminales de expresiones y asignaciones
non terminal exprRegalo, regaloManual, regalocompradoRelacional, regaloprinBinario, regaloprinUnario, pedirBolsaNavidena, printBolsaNavidena, readBolsaNavidena ;

//No terminales de estructuras de control 
non terminal pesebre, while_esperarasanta, condicion_esperarasanta, for_envuelve, do_hace, if_elfo, elif_hada_duende, elif_hada, def_elif_hada, else_duende;

/* No terminal Inicial */
non terminal navidad; 


/*Definicion del orden de las precedencias*/

precedence left res_dancer, sum_dasher;
precedence left div_int_vixen, div_float_blitzen, mul_prancer;
precedence left mod_comet, pow_cupid;

precedence left GRINCH,
                QUIEN;
                
precedence left le_candycane,
            ge_snowflake,
            ne_tinseltoes,
            e_jinglebell,
            l_slinky,
            g_merryberry;

precedence left and_melchior;
precedence left or_balthassar;
precedence left not_gaspar;


start with navidad;

//Simbolo inicial
navidad ::=
    {:
//        listaTablasSimbolos.put(globalHash, new ArrayList<String>());
    :}
     bolsaNavidena {:
//        hola();
//        adios();
    if (!(listaTablasSimbolos.containsKey("main"))) {
        //listaTablasSimbolos.get(currHash).add(tipoEntrada);
        semantic_error("main","");
    } 
    //validarFuncs();
    imprimirTablaSimbolos();
    escribirTablaSimbolos();
    System.out.println("Fin del parseo...\n");
  
  :} ;

bolsaNavidena ::=  {:
    System.out.println("\nInicio del parseo...");
  :}  bolsaNavidenaAux
    ;

//Llamada recursiva para llamar 1 o mas funciones 
bolsaNavidenaAux ::= defBolsaNavidena | bolsaNavidenaAux defBolsaNavidena ;


//Definicion del tipo y llamado al codigo dentro de la funcion
defBolsaNavidena ::= bolsasNavidenas codigoBolsaNavidena;

//Se definen tipos de funciones: main,void, tipo sin parametros y tipo con parametros 
bolsasNavidenas ::= FESTIVAL t_int_sinterklass ARBOL ABRECUENTO CIERRACUENTO
                    {://Se ingresan al hash la info de la funcion declarada y se inicializa una nueva tabla de simbolos

                        if (listaTablasSimbolos.containsKey("main")) {//Se verifica que no se haya declarado main antes
                            //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                            semantic_error("fun", "main");
                        } 
                        else{
                            String tipoTabla = " Tipo Dato: ";
                            tipoTabla =  tipoTabla + "int;\n";
                            ArrayList<String> funMain = new ArrayList<String>();
                            currHash = "main";
                            String nombreDato = " Nombre: ";
                            nombreDato = nombreDato + "main" + ";";
                            String tipoEntrada = "Tipo Entrada: ";
                            tipoEntrada = tipoEntrada + "Funcion;";
                            funMain.add(tipoEntrada);
                            funMain.add(nombreDato);
                            funMain.add(tipoTabla); 
                            pilaSimbolos.put(currHash, new TablaSimbolo()); //Cambiar contexto
                            RESULT = "main";
                            pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("funcion", "int", "main")); //Agregar nuevo simbolo
                            listaTablasSimbolos.put(currHash, funMain); 
                            funcs.add(new FunctionObject("main", TipoDato.INT, new TipoDato[] {}, true));
                        }                        
                    :}
                    | FESTIVAL tsantaclaus:t PERSONA:per ABRECUENTO CIERRACUENTO 
                    {: //Se ingresan al hash la info de la funcion declarada y se inicializa una nueva tabla de simbolos

/*
                        if (listaTablasSimbolos.containsKey(per.toString())) {
                            //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                            semantic_error("fun", per.toString());
                        } 
                        else{
                        }
*/
                        var tipoStr = t.toString();
                        if (!tipoStr.equals("char") && !tipoStr.equals("int") && !tipoStr.equals("float") && !tipoStr.equals("boolean")) {
                            semantic_error("ftipo", tipoStr);
                        }
                        else{
                            if (listaTablasSimbolos.containsKey(per.toString())) {
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                semantic_error("fun", per.toString());
                            } 
                            else{
                                currHash = per.toString();
                                String tipoDato = " Tipo Dato: ";
                                tipoDato =  tipoDato + t.toString()  + ".\n";
                                String nombreDato = " Nombre: ";
                                nombreDato = nombreDato + per.toString() + ",";
                                String tipoEntrada = "Tipo Entrada: ";
                                tipoEntrada = tipoEntrada + "Funcion" + ",";
                                tipoEntrada = tipoEntrada + nombreDato + tipoDato;
                                ArrayList<String> fun = new ArrayList<String>();
                                fun.add(tipoEntrada);
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada); 
                                pilaSimbolos.put(currHash, new TablaSimbolo()); //Cambiar contexto

                                RESULT = per.toString();
                                pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("funcion", t.toString(), per.toString())); //Agregar nuevo simbolo
                                listaTablasSimbolos.put(currHash, fun);
                                funcs.add(new FunctionObject(per.toString(), Dato.tipoFromString(t.toString()), new TipoDato[] {}, false));
                            }
                        }
                    :}
                    | FESTIVAL SINREGALO PERSONA:per ABRECUENTO CIERRACUENTO 
                    {: //Se ingresan al hash la info de la funcion declarada y se inicializa una nueva tabla de simbolos
                        

                        if (listaTablasSimbolos.containsKey(per.toString())) {
                            //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                            semantic_error("fun", per.toString());
                        } 
                        else{
                            currHash = per.toString();
                            String tipoDato = " Tipo Dato: ";
                            tipoDato =  tipoDato + "void"  + ".\n";
                            String nombreDato = " Nombre: ";
                            nombreDato = nombreDato + per.toString() + ",";
                            String tipoEntrada = "Tipo Entrada: ";
                            tipoEntrada = tipoEntrada + "Funcion" + ",";
                            tipoEntrada = tipoEntrada + nombreDato + tipoDato;
                            ArrayList<String> fun = new ArrayList<String>();
                            fun.add(tipoEntrada);
                            //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                            pilaSimbolos.put(currHash, new TablaSimbolo()); //Cambiar contexto

                            RESULT = per.toString();
                            pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("funcion", "void", per.toString())); //Agregar nuevo simbolo 
                            listaTablasSimbolos.put(currHash, fun);
                            funcs.add(new FunctionObject(per.toString(), TipoDato.VOID, new TipoDato[] {}, false));
                        }
                        

                    :}

                    | FESTIVAL tsantaclaus:t PERSONA:per ABRECUENTO
                    {: //Se ingresan al hash la info de la funcion declarada y se inicializa una nueva tabla de simbolos
                        var tipoStr = t.toString();
                        if (!tipoStr.equals("char") && !tipoStr.equals("int") && !tipoStr.equals("float") && !tipoStr.equals("boolean")) {
                            semantic_error("ftipo", tipoStr);
                        }
                        else{
                            if (listaTablasSimbolos.containsKey(per.toString())) {
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                semantic_error("fun", per.toString());
                            } 
                            else{
                                currHash = per.toString();
                                String tipoDato = " Tipo Dato: ";
                                tipoDato =  tipoDato + t.toString()  + ".\n";
                                String nombreDato = " Nombre: ";
                                nombreDato = nombreDato + per.toString() + ",";
                                String tipoEntrada = "Tipo Entrada: ";
                                tipoEntrada = tipoEntrada + "Funcion" + ",";
                                tipoEntrada = tipoEntrada + nombreDato + tipoDato;
                                ArrayList<String> fun = new ArrayList<String>();
                                fun.add(tipoEntrada);
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                pilaSimbolos.put(currHash, new TablaSimbolo()); //Cambiar contexto

                                RESULT = per.toString();
                                pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("funcion", t.toString(), per.toString())); //Agregar nuevo simbolo  
                                listaTablasSimbolos.put(currHash, fun);
                                funcs.add(new FunctionObject(per.toString(), Dato.tipoFromString(t.toString()), new TipoDato[] {}, false));
                            }
                        }

                    :}                    
                      paramBastoncitos CIERRACUENTO 

                    | FESTIVAL SINREGALO PERSONA:per ABRECUENTO 
//Se ingresan al hash la info de la funcion declarada y se inicializa una nueva tabla de simbolos
                    {:  
                        if (listaTablasSimbolos.containsKey(per.toString())) {
                            //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                            semantic_error("fun", per.toString());
                        } 
                        else{
                            currHash = per.toString();
                            String tipoDato = " Tipo Dato: ";
                            tipoDato =  tipoDato + "void"  + ".\n";
                            String nombreDato = " Nombre: ";
                            nombreDato = nombreDato + per.toString() + ",";
                            String tipoEntrada = "Tipo Entrada: ";
                            tipoEntrada = tipoEntrada + "Funcion" + ",";
                            tipoEntrada = tipoEntrada + nombreDato + tipoDato;
                            ArrayList<String> fun = new ArrayList<String>();
                            fun.add(tipoEntrada);
                            listaTablasSimbolos.put(currHash, fun);
                            pilaSimbolos.put(currHash, new TablaSimbolo()); //Cambiar contexto

                            RESULT = per.toString();
                            pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("funcion", "void", per.toString())); //Agregar nuevo simbolo 
                            funcs.add(new FunctionObject(per.toString(), TipoDato.VOID, new TipoDato[] {}, false));
                        }                     

                    :}
                    paramBastoncitos CIERRACUENTO 
                    ;


//No terminal de palabras reservadas para Tipos de datos
tsantaclaus ::= 
	t_int_sinterklass:t {: RESULT = t; :} |
	t_float_santa:t {: RESULT = t; :}  |
	t_string_nicolas:t {: RESULT = t; :}  |
	t_bool_colacho:t {: RESULT = t; :}  |
	t_char_dedmoroz:t {: RESULT = t; :} ;


//No terminal de literales//Cambios
tlsantaclaus ::=
	l_int_dedmoroz:l {: RESULT = new Dato(l, TipoDato.INT); :}  |
	l_float_padrenavidad:l {: RESULT = new Dato(l, TipoDato.FLOAT); :}  |
	l_string_nicolas:l {: RESULT = new Dato(l, TipoDato.STRING); :}  | 
	l_MINIREGALO:l {: RESULT = new Dato(l, TipoDato.CHAR); :}  |   
	l_tPAPANOEL:l {: RESULT = new Dato(l, TipoDato.BOOLEAN); :}  | 
	l_fPAPANOEL:l {: RESULT = new Dato(l, TipoDato.BOOLEAN); :} ;  

 

//Cuerpo de la funcion con las lineas de codigo entre corchetes {...}
codigoBolsaNavidena ::= ABREREGALO lineasDeNavidad CIERRAREGALO | ABREREGALO error CIERRAREGALO; 


//Definicion recursiva para poder llamar varias lineas de Codigo
lineasDeNavidad ::= auxLineasDeNavidad | lineasDeNavidad auxLineasDeNavidad ;

//Distintos tipos de lineas que se pueden utilizar dentro de funciones incluyendo estructuras de control y asignaciones
auxLineasDeNavidad ::= creaRegalo FINREGALO | asignaRegalo FINREGALO
                        | pesebre
                        | exprRegalo FINREGALO
                        | PERSONA asignaMultiplesRegalos FINREGALO
                        | NARRA ABRECUENTO exprRegalo CIERRACUENTO FINREGALO
                        //print("",1,2,3)|
                        | NARRA ABRECUENTO l_string_nicolas SEPARAREGALO expresionesBastoncitos CIERRACUENTO FINREGALO
                        | RETORNAREGALO exprRegalo:ex FINREGALO //RETORNAREGALO exprRegalo FINREGALO
{:
                        var typeFunc = funcs.get(funcs.size()-1).getTipoReturn(); //
                        var typeExpr = ((Dato)ex).getTipo();

                        if (typeExpr != typeFunc) {
                          semantic_error("misc", ("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Debido a que el retorno es invalido para la funcion de tipo: " + typeFunc.toString() ));
                        }
                        else {
                          funcs.get(funcs.size()-1).setTHayRetorno(true);
                        }
:}
                                | RETORNAREGALO FINREGALO   //ver currhash
{:

                        var typeFunc = funcs.get(funcs.size()-1).getTipoReturn(); //
                        //var typeExpr = ((Dato)ex).getTipo();

                        if (typeFunc != TipoDato.VOID) {
                          semantic_error("misc", ("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Debido a que el retorno es invalido para la funcion de tipo: " + typeFunc.toString() ));
                        }
                        else {
                          funcs.get(funcs.size()-1).setTHayRetorno(true);
                        }                        
:}
                                | codigoBolsaNavidena
                                | CORTA FINREGALO //Agregar manejo del break 
                                | error FINREGALO;

//Creacion, llamados y asignaciones a variables, incluyendo arreglos
//local int var; local int var = 2; local int arreglo [10]
creaRegalo ::= NATIVIDAD tsantaclaus:t PERSONA:per 
                {://Se ingresan a la tabla la info del simbolo declarado
                

                    String tipoDato = " Tipo Dato: ";
                    tipoDato =  tipoDato + t.toString()  + ".\n";
                    String nombreDato = " Nombre: ";
                    nombreDato = nombreDato + per.toString() + ",";
                    String tipoEntrada = "Tipo Entrada: ";
                    tipoEntrada = tipoEntrada + "Local" + ",";
                    tipoEntrada = tipoEntrada + nombreDato + tipoDato;
                    List<String> entries = listaTablasSimbolos.get(currHash);
                    Boolean elementoExiste = false;
                    if (entries != null) {
                        for (String entry : entries) {
                            if (entry.contains(nombreDato)) {
                                elementoExiste = true;
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                //System.out.println("\nVARIABLE HA SIDO DECLARADA");
                                
                            }
                        }
                    }
                    
                    if(elementoExiste == false){
                        pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("local", t.toString(), per.toString()));
                        //funcs.get(funcs.size()-1).insertarTipoParametro(Dato.tipoFromString(t.toString()));
                        pilaSimbolos.get(currHash).incrementarIndice(4);                    
                        listaTablasSimbolos.get(currHash).add(tipoEntrada);                       
                    }
                    else{
                        semantic_error("local", per.toString());
                    }

                        
                :}
                | NATIVIDAD tsantaclaus:t PERSONA:per ENTREGA exprRegalo:e
                {://Se ingresan a la tabla la info del simbolo declarado
                    var data = (Dato)e;
                    String tipoDato = " Tipo Dato: ";
                    tipoDato =  tipoDato + t.toString()  + ".\n";
                    String nombreDato = " Nombre: ";
                    nombreDato = nombreDato + per.toString() + ",";
                    String tipoEntrada = "Tipo Entrada: ";
                    tipoEntrada = tipoEntrada + "Local" + ",";
                    tipoEntrada = tipoEntrada + nombreDato + tipoDato;
                    List<String> entries = listaTablasSimbolos.get(currHash);
                    Boolean elementoExiste = false;
                    if (entries != null) {
                        for (String entry : entries) {
                            if (entry.contains(nombreDato)) {
                                elementoExiste = true;
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                System.out.println("\nVARIABLE HA SIDO DECLARADA");
                                
                            }
                        }
                    }
                    
                    if(elementoExiste == false){    
                       if(data.getTipo() == Dato.tipoFromString(t.toString())){
                            pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("local", t.toString(), per.toString()));
                            //funcs.get(funcs.size()-1).insertarTipoParametro(Dato.tipoFromString(t.toString()));
                            pilaSimbolos.get(currHash).incrementarIndice(4);                              
                            listaTablasSimbolos.get(currHash).add(tipoEntrada);
                        }              
                        else{
                            semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "El tipo " + data.getTipo() + " no es valido para la variable " + per.toString()));

                        }
                        //System.out.println("\nVARIABLE NO HA SIDO DECLARADA");                        
                    }
                    //listaTablasSimbolos.get(currHash).add(tipoEntrada); 
                    else{
                        semantic_error("local", per.toString());
                    }
                        
                :}
                | NATIVIDAD tsantaclaus:t PERSONA:per  ABREEMPAQUE exprRegalo:e CIERRAEMPAQUE
                {://Se ingresan a la tabla la info del simbolo declarado
                    var data = (Dato)e;
                    //System.out.println("\n INDICE DEL ARREGLO es:" + data.getTipo());
                    
                    String tipoDato = " Tipo Dato: ";
                    tipoDato =  tipoDato +  t.toString() + "[ ] .\n";
                    String nombreDato = " Nombre: ";
                    nombreDato = nombreDato + per.toString() + ",";
                    String tipoEntrada = "Tipo Entrada: ";
                    tipoEntrada = tipoEntrada + "Local" + ",";
                    tipoEntrada = tipoEntrada + nombreDato + tipoDato;
                    //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                    List<String> entries = listaTablasSimbolos.get(currHash);
                    Boolean elementoExiste = false;
                    if (entries != null) {
                        for (String entry : entries) {
                            if (entry.contains(nombreDato)) {
                                elementoExiste = true;
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                //System.out.println("\nVARIABLE HA SIDO DECLARADA");
                                
                            }
                        }
                    }
                    
                    if(elementoExiste == false){
                        if(data.getTipo() == TipoDato.INT){
                            pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("local", t.toString() + "[]", per.toString()));
                            pilaSimbolos.get(currHash).incrementarIndice(4); 
                            listaTablasSimbolos.get(currHash).add(tipoEntrada);
                            //System.out.println("\nVARIABLE NO HA SIDO DECLARADA");   
                        }                     
                        else{
//                          //errorActual = "Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "El tipo " + pExpresion + " no es valido para incializar arreglos";
                            //data = "";

                            semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "El tipo " + data.getTipo() + " no es valido para incializar arreglos"));
                        }
                    }
                    else{
                        semantic_error("local", per.toString());
                    } 
                        
                :}
                | NATIVIDAD tsantaclaus:t PERSONA:per ABREEMPAQUE exprRegalo:e1 CIERRAEMPAQUE ENTREGA asignaMultiplesRegalos:e2 //exprRegalo:e2
                {://Se ingresan a la tabla la info del simbolo declarado
                    var data1 = (Dato)e1;
                    var data2 = (Dato)e2;
                    String tipoDato = " Tipo Dato: ";
                    tipoDato =  tipoDato +  t.toString() + "[ ] .\n";
                    String nombreDato = " Nombre: ";
                    nombreDato = nombreDato + per.toString() + ",";
                    String tipoEntrada = "Tipo Entrada: ";
                    tipoEntrada = tipoEntrada + "Local" + ",";
                    tipoEntrada = tipoEntrada + nombreDato + tipoDato;
                    //listaTablasSimbolos.get(currHash).add(tipoEntrada); 
                    List<String> entries = listaTablasSimbolos.get(currHash);
                    Boolean elementoExiste = false;
                    if (entries != null) {
                        for (String entry : entries) {
                            if (entry.contains(nombreDato)) {
                                elementoExiste = true;
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                //System.out.println("\nVARIABLE HA SIDO DECLARADA");
                                
                            }
                        }
                    }
                    
                    if(elementoExiste == false){//data1.getTipo() == TipoDato.INT
                        if(data1.getTipo() == TipoDato.INT){

                            if(data2.getTipo() != TipoDato.NULO){
                                TipoDato type = Dato.tipoFromString(t.toString() + "[]");
                                if(data2.getTipo() != type){
                                    semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Tipo de dato declarado invalido para el arreglo")); 
                                }
                                else{//////
                                    if((int)data1.getValor() != e2.getValor().size()){
                                        semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "No se han incluido todas las expresiones que se deben ingresar al arreglo")); 
                                    }
                                    else{
                                        listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                        //pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("local", t.toString() + "[]", per.toString()));
                                        pilaSimbolos.get(currHash).incrementarIndice(4); 
                                        listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                    }
                                }
                             }
                             else{
                                semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Asignacion de arreglo incorrecta"));                                     
                             }
                        }
                        else{
                            System.out.println("IS IT HEREEEE");
                            semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "El tipo " + data1.getTipo() + " no es valido para incializar arreglos"));                        
                        }
                        //System.out.println("\nVARIABLE NO HA SIDO DECLARADA");                        
                    }
                    else{
                        semantic_error("local", per.toString());
                    }                
                :}
		| NATIVIDAD tsantaclaus:t PERSONA:per ABREEMPAQUE exprRegalo:e1 CIERRAEMPAQUE asignaMultiplesRegalos:e2 //ABREREGALO expresionesBastoncitos CIERRAREGALO
                {://Se ingresan a la tabla la info del simbolo declarado
                    var data1 = (Dato)e1;
                    var data2 = (Dato)e2;
                    String tipoDato = " Tipo Dato: ";
                    tipoDato =  tipoDato +  t.toString() + "[ ] .\n";
                    String nombreDato = " Nombre: ";
                    nombreDato = nombreDato + per.toString() + ",";
                    String tipoEntrada = "Tipo Entrada: ";
                    tipoEntrada = tipoEntrada + "Local" + ",";
                    tipoEntrada = tipoEntrada + nombreDato + tipoDato;
                    //listaTablasSimbolos.get(currHash).add(tipoEntrada); 
                    List<String> entries = listaTablasSimbolos.get(currHash);
                    Boolean elementoExiste = false;
                    if (entries != null) {
                        for (String entry : entries) {
                            if (entry.contains(nombreDato)) {
                                elementoExiste = true;
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                //System.out.println("\nVARIABLE HA SIDO DECLARADA");
                                
                            }
                        }
                    }
                    
                    if(elementoExiste == false){//data1.getTipo() == TipoDato.INT
                        if(data1.getTipo() == TipoDato.INT){

                            if(data2.getTipo() != TipoDato.NULO){
                                TipoDato type = Dato.tipoFromString(t.toString() + "[]");
                                if(data2.getTipo() != type){
                                    semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Tipo de dato declarado invalido para el arreglo")); 
                                }
                                else{//////(int)data1.getValor()
                                    var indice = (String)data1.getValor();
                                    if(Integer.parseInt(indice) != ((ArrayList<Dato>)data2.getValor()).size()){
                                        semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "No se han incluido todas las expresiones que se deben ingresar al arreglo")); 
                                    }
                                    else{
                                        listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                        //pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("local", t.toString() + "[]", per.toString()));
                                        pilaSimbolos.get(currHash).incrementarIndice(4); 
                                        listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                    }
                                }
                             }
                             else{
                                semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Asignacion de arreglo incorrecta"));                                     
                             }
                        }
                        else{

                            semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "El tipo " + data1.getTipo() + " no es valido para incializar arreglos"));                        
                        }
                        //System.out.println("\nVARIABLE NO HA SIDO DECLARADA");                        
                    }
                    else{
                        semantic_error("local", per.toString());
                    }
                :}
                ; // | PERSONA ;

asignaRegalo ::= PERSONA:per ABREEMPAQUE exprRegalo:e CIERRAEMPAQUE ENTREGA exprRegalo:e 

                                | 

                                  PERSONA:per ENTREGA exprRegalo:e ;

asignaMultiplesRegalos ::= ENTREGA ABREREGALO expresionesBastoncitos:e CIERRAREGALO {:
                             var expresiones = (ArrayList<Dato>)e;
                             boolean mismosTipos = true;

                             for(Dato expr: expresiones){
                                if(expr.getTipo() != expresiones.get(0).getTipo()){
                                    mismosTipos = false;
                                    semantic_error("misc", ("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que se tienen diferentes tipos en el conjunto de expresiones") );
                                    RESULT = new Dato("null", TipoDato.NULO);
                                }
                             }
                             if(mismosTipos == true){
                                if(expresiones.get(0).getTipo() == TipoDato.INT){
                                    RESULT = new Dato(expresiones, TipoDato.INTARR); 
                                }
                                else if(expresiones.get(0).getTipo() == TipoDato.CHAR){
                                    RESULT = new Dato(expresiones, TipoDato.CHARARR);
                                }
                                else {
                                    RESULT = new Dato(expresiones, TipoDato.NULO);                                    
                                }
                             }
                            :}
;

//Diferentes casos posibles de llamar a una funcion 
pedirBolsaNavidena ::= PERSONA:per ABRECUENTO CIERRACUENTO 
{:
    RESULT = new Dato("null", TipoDato.NULO);
    var func = buscarFunc(per.toString()); //
    if (func == null) {
       semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que no se ha definido la funcion: " + per.toString()) );
    }
    else {
      if (func.getTParams().length > 0) {
        semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que faltan parametros en la funcion: " + per.toString()) );
      }
      else {
        RESULT = new Dato("null", func.getTipoReturn());
      }
    }
:}

                                           |
PERSONA:per ABRECUENTO expresionesBastoncitos:es CIERRACUENTO
{:
    RESULT = new Dato("null", TipoDato.NULO);
    var func = buscarFunc(per.toString()); //
    if (func == null) {
       semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que no se ha definido la funcion: " + per.toString()) );
    }
    else {
      var nParams = func.getTParams();
      var bastoncitos = (ArrayList<Dato>)es;
      boolean paramValidos = true;
      System.out.println("Num de Params es: " + nParams.length);
      System.out.println("Num de bastoncitos es: " + bastoncitos.size());
      if (nParams.length != bastoncitos.size()) {
        paramValidos = false;
        semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que no hay cantidad suficiente de parametros en la funcion: " + per.toString()) );
      }
      else {
        for (int k = 0; k < nParams.length; k++) {
          if (nParams[k] != bastoncitos.get(k).getTipo()) {
            paramValidos = false;
            semantic_error("misc",("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que los parametros no son del tipo correcto en la llamada a la funcion: " + per.toString()) );
            break;
          }
        }
        if(paramValidos == true){
            RESULT = new Dato("null", func.getTipoReturn());
        }
      }
    }
:}
        | readBolsaNavidena ;//printBolsaNavidena ;//;


//Llamados de print (expresion) y ("", , ...)
//printBolsaNavidena ::= NARRA ABRECUENTO exprRegalo CIERRACUENTO;
//					| NARRA ABRECUENTO l_string_nicolas SEPARAREGALO expresionesBastoncitos CIERRACUENTO;

//Llamados de read con cero parametros y con el caso de que hayan uno o mas parametros 
readBolsaNavidena ::= ESCUCHA ABRECUENTO CIERRACUENTO | ESCUCHA ABRECUENTO expresionesBastoncitos CIERRACUENTO;


//Tipos de expresiones presentes en el lenguaje, incluyendo literales, asignaciones, multiples expresiones en parentesis 
//expresiones aritmeticas unarias/binarias, logicas, relacionales y llamados a funciones
exprRegalo ::=  tlsantaclaus :l {: RESULT = l; :} 
                | regalocompradoRelacional:e  {: RESULT = e; :} | regaloManual:e  {: RESULT = e; :} | regaloprinBinario:e  {: RESULT = e; :} | regaloprinUnario:e  {: RESULT = e; :} 
                                | PERSONA:per  {:
                                    if (getTipo(per.toString(), true) != TipoDato.NULO) {
                                          //!var dir = getDireccion(id.toString());
                                          //!var registro = getUnoccupiedRegister();
                                          //!codeBuffer.append("lw " + registro + ", " + dir + "\n");
                                          RESULT = new Dato(per.toString(), getTipo(per.toString(), true));//, registro);
                                    } else {
                                          RESULT = new Dato("null", TipoDato.NULO);
                                        }
                                    :}      
                                | PERSONA ABREEMPAQUE exprRegalo CIERRAEMPAQUE 
                                | ABRECUENTO expresionesBastoncitos CIERRACUENTO
				| ABREEMPAQUE expresionesBastoncitos CIERRAEMPAQUE
                                | pedirBolsaNavidena:p {: RESULT = p; :}; //


//Estructuras de control utilizadas en el lenguaje
pesebre ::= while_esperarasanta | for_envuelve  | do_hace | if_elfo ; //| switch_trineo 

//Definicien del do-while: do{...} until()|
do_hace ::= HACE ABREREGALO lineasDeNavidad CIERRAREGALO REVISA ABRECUENTO condicion_esperarasanta CIERRACUENTO FINREGALO
             | HACE ABREREGALO CIERRAREGALO REVISA ABRECUENTO condicion_esperarasanta CIERRACUENTO FINREGALO; 

//REVISA ABRECUENTO condicion_esperarasanta CIERRACUENTO FINREGALO 
//            HACE ABREREGALO CIERRAREGALO REVISA ABRECUENTO condicion_esperarasanta CIERRACUENTO FINREGALO ;


//Definicion del bucle while () {...}
while_esperarasanta ::= ESPERARASANTA ABRECUENTO condicion_esperarasanta CIERRACUENTO ABREREGALO lineasDeNavidad CIERRAREGALO
                        | ESPERARASANTA ABRECUENTO condicion_esperarasanta CIERRACUENTO ABREREGALO CIERRAREGALO ;

condicion_esperarasanta ::=  l_tPAPANOEL:l {: RESULT = l; :}  
                              |   l_fPAPANOEL:l {: RESULT = l; :} 
                        | regalocompradoRelacional; //| exprRegalo

//Definicion for(int i = 0; i < 4; i++){...}
for_envuelve ::= ENVUELVE ABRECUENTO asignaRegalo FINREGALO regalocompradoRelacional FINREGALO regaloprinUnario CIERRACUENTO ABREREGALO lineasDeNavidad CIERRAREGALO 
                | ENVUELVE ABRECUENTO asignaRegalo FINREGALO regalocompradoRelacional FINREGALO regaloprinUnario CIERRACUENTO ABREREGALO CIERRAREGALO ;

//Los casos del if(elfo), else(duende) y elif(hada). if(), if(){}else{}, if()elif(){}...else{}
if_elfo ::= ELFO ABRECUENTO condicion_esperarasanta CIERRACUENTO ABREREGALO lineasDeNavidad CIERRAREGALO 
		| ELFO ABRECUENTO condicion_esperarasanta CIERRACUENTO ABREREGALO lineasDeNavidad CIERRAREGALO DUENDE ABREREGALO lineasDeNavidad CIERRAREGALO 
		| ELFO ABRECUENTO condicion_esperarasanta CIERRACUENTO ABREREGALO lineasDeNavidad CIERRAREGALO elif_hada_duende
		| ELFO ABRECUENTO condicion_esperarasanta CIERRACUENTO ABREREGALO lineasDeNavidad CIERRAREGALO elif_hada_duende DUENDE ABREREGALO lineasDeNavidad CIERRAREGALO ;

//Caso elif con varios posibles elif y otro elif else
elif_hada_duende ::= elif_hada | else_duende elif_hada ;
elif_hada ::= def_elif_hada | elif_hada def_elif_hada ;
def_elif_hada ::= HADA ABRECUENTO condicion_esperarasanta CIERRACUENTO ABREREGALO lineasDeNavidad CIERRAREGALO ;
else_duende ::= DUENDE ABREREGALO lineasDeNavidad CIERRAREGALO ;


//Operaciones relacionales
// a > b,  a < b, a == b, a != b, a => b, a =< b
regalocompradoRelacional ::= exprRegalo:a g_merryberry exprRegalo:b 
{:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos(">", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " > " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " > " + e2.getValor().toString()), TipoDato.FLOAT);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :}  
                                | 
                            exprRegalo:a l_slinky exprRegalo:b 
{:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("<", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " < " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " < " + e2.getValor().toString()), TipoDato.FLOAT);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :} 
                                |
                            exprRegalo:a e_jinglebell exprRegalo:b 
{:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("==", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " == " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " == " + e2.getValor().toString()), TipoDato.FLOAT);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :} 
                                |
                             exprRegalo:a ne_tinseltoes exprRegalo:b 
{:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("!=", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " != " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " != " + e2.getValor().toString()), TipoDato.FLOAT);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :} 
                                |
                            exprRegalo:a ge_snowflake exprRegalo:b 
{:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("=>", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " => " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " => " + e2.getValor().toString()), TipoDato.FLOAT);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :} 
                                
                                |
                        exprRegalo:a le_candycane exprRegalo:b 
{:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("=<", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " =< " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " =< " + e2.getValor().toString()), TipoDato.FLOAT);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :} ;


//Lista de expresiones (,,), definidos recursivamente para poder tener uno o mas 
//expresionesBastoncitos ::= defExprBastoncito | expresionesBastoncitos SEPARAREGALO  defExprBastoncito ;
expresionesBastoncitos ::= exprRegalo:ex 
  {: 
    var bastoncitos = new ArrayList<Dato>();
    bastoncitos.add((Dato)ex);
    RESULT = bastoncitos;
  :}                        
   | expresionesBastoncitos:es SEPARAREGALO  exprRegalo:ex 
  {: 
    var bastoncitos = (ArrayList<Dato>)es;
    bastoncitos.add((Dato)ex);
    RESULT = bastoncitos;
  :} ;

//defExprBastoncito ::= exprRegalo ;

//Parametros de funciones (,,), definidos recursivamente para poder tener uno o mas 
paramBastoncitos ::= defParamBastoncito | paramBastoncitos SEPARAREGALO defParamBastoncito ;
defParamBastoncito ::= tsantaclaus:t PERSONA:per 
                {:
 
                    String tipoDato = " Tipo Dato: ";
                    tipoDato =  tipoDato + t.toString()  + ".\n";
                    String nombreDato = " Nombre: ";
                    nombreDato = nombreDato + per.toString() + ",";
                    String tipoEntrada = "Tipo Entrada: ";
                    tipoEntrada = tipoEntrada + "Parametro" + ",";
                    tipoEntrada = tipoEntrada + nombreDato + tipoDato;
  

                    List<String> entries = listaTablasSimbolos.get(currHash);
                    Boolean elementoExiste = false;
                    if (entries != null) {
                        for (String entry : entries) {
                            if (entry.contains(nombreDato)) {
                                elementoExiste = true;
                                //listaTablasSimbolos.get(currHash).add(tipoEntrada);
                                //System.out.println("\nVARIABLE HA SIDO DECLARADA");
                                
                            }
                        }
                    }
                    
                    if(elementoExiste == false){
                        pilaSimbolos.get(currHash).getTablaSimbolos().add(new Simbolo("parametro", t.toString(), per.toString()));
                        funcs.get(funcs.size()-1).insertarTipoParametro(Dato.tipoFromString(t.toString()));
                        listaTablasSimbolos.get(currHash).add(tipoEntrada);
                        pilaSimbolos.get(currHash).incrementarIndice(4);
                        //System.out.println("\nVARIABLE NO HA SIDO DECLARADA");                        
                    }   
                    else{
                        semantic_error("param", per.toString());
                    }                     
                :}                    
                ;

//Operaciones logicas
// a ^ b, a # b, !a 
regaloManual ::= exprRegalo:a and_melchior exprRegalo:b 
{:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.BOOLEAN));
                            var type = validarTipos("AND", e1, e2, tipos);
                            if(type == TipoDato.BOOLEAN){
//                               System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " ^ " + e2.getValor().toString(), TipoDato.BOOLEAN);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :}  
                            |
                            exprRegalo:a or_balthassar exprRegalo:b 
{:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.BOOLEAN));
                            var type = validarTipos("OR", e1, e2, tipos);
                            if(type == TipoDato.BOOLEAN){
//                               System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " # " + e2.getValor().toString(), TipoDato.BOOLEAN);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :}  
                            |
			   not_gaspar exprRegalo:a 
{:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT, TipoDato.BOOLEAN));
                            var type = validarTipos("NOT", e1, e1, tipos);
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato("! " + e1.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato("! " + e1.getValor().toString(), TipoDato.FLOAT);
                            }
                            else if(type == TipoDato.BOOLEAN){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato("! " + e1.getValor().toString(), TipoDato.BOOLEAN);
                            }
                            else{
    //                           // System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :}
                            ;

//Operaciones aritmeticas unarias --a, ++a, a++, a--
regaloprinUnario ::= QUIEN PERSONA:per {:

                        var type = getTipo(per.toString(),false);
                        if((existeValor(per.toString())) != null){
//                            System.out.println("ENTRO AQUILAS?");
                            semantic_error("misc", ("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que no se ha definido el id: " + per.toString()));
                            RESULT = new Dato("null", TipoDato.NULO);
                        }
                        else{ 
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato("--" + per.toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato("--" + per.toString(), TipoDato.FLOAT);
                            }
                            else{
    //                           // System.out.println("ENTRO AQUI3?");
                                semantic_error("misc", ("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que el tipo " + type + " no es valido en incremento para: " + per.toString()));
                                RESULT = new Dato("null", TipoDato.NULO);
                            }                            
                        }                         
                    :}
                        
                    | 
                        GRINCH PERSONA:per {:

                        var type = getTipo(per.toString(),false);
                        if((existeValor(per.toString())) != null){
//                            System.out.println("ENTRO AQUILAS?");
                            semantic_error("misc", ("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que no se ha definido el id: " + per.toString()));
                            RESULT = new Dato("null", TipoDato.NULO);
                        }
                        else{ 
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato("++" + per.toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato("++" + per.toString(), TipoDato.FLOAT);
                            }
                            else{
    //                           // System.out.println("ENTRO AQUI3?");
                                semantic_error("misc", ("Error semantico en la linea " + (lex.getLine() + 1) + " columna " + (lex.getColumn() + 1) + ": " + "Ya que el tipo " + type + " no es valido en incremento para: " + per.toString()));
                                RESULT = new Dato("null", TipoDato.NULO);
                            }                            
                        }                         
                    :} ; //|


//Operaciones aritmeticas binarias a+b; a-b, a/b, a//b,a*b a**b, 
regaloprinBinario ::= exprRegalo:a sum_dasher exprRegalo:b  {:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("suma", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                                System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " + " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " + " + e2.getValor().toString(), TipoDato.FLOAT);
                            }
                            else{
    //                           // System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :}
                                        |
                        exprRegalo:a res_dancer exprRegalo:b {:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("resta", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                               //System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " - " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " - " + e2.getValor().toString(), TipoDato.FLOAT);
                            }
                            else{
    //                           // System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :}
                                        |
                        exprRegalo:a mul_prancer exprRegalo:b {:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("multiplicacion", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                               //System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " * " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " * " + e2.getValor().toString(), TipoDato.FLOAT);
                            }
                            else{
    //                           // System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :} 
                                        |
                        exprRegalo:a div_int_vixen exprRegalo:b {:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT));
                            var type = validarTipos("division entera", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                               //System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " // " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                               //System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " // " + e2.getValor().toString(), TipoDato.FLOAT);
                            }
                            else{
    //                            //System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :}
                                        |
                        exprRegalo:a div_float_blitzen exprRegalo:b {:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.FLOAT));
                            var type = validarTipos("division flotante", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                               //System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " / " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                              // System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " / " + e2.getValor().toString(), TipoDato.FLOAT);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :}
                                        |
                        exprRegalo:a mod_comet exprRegalo:b {:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("modulo", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                               System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " % " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                               System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " % " + e2.getValor().toString(), TipoDato.FLOAT);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :}
                                        |
                        exprRegalo:a pow_cupid exprRegalo:b {:
                            var e1 = (Dato)a;
                            //var reg = getUnoccupiedRegister();
                            var e2 = (Dato)b;
                            var tipos =  new ArrayList<TipoDato>(Arrays.asList(TipoDato.INT, TipoDato.FLOAT));
                            var type = validarTipos("potencia", e1, e2, tipos);
                            if(type == TipoDato.INT){
//                               System.out.println("ENTRO AQUI1?");
                                RESULT = new Dato(e1.getValor().toString() + " ** " + e2.getValor().toString(), TipoDato.INT);
                            }
                            else if(type == TipoDato.FLOAT){
 //                               System.out.println("ENTRO AQUI2?");
                                RESULT = new Dato(e1.getValor().toString() + " ** " + e2.getValor().toString(), TipoDato.FLOAT);
                            }
                            else{
    //                            System.out.println("ENTRO AQUI3?");
                                RESULT = new Dato("null", TipoDato.NULO);
                            } :} ;
